"""
End-to-end tests for complete application workflows.

Generated by: testing-agent
Source: Full application stack
Requirements: FR-GUI-001, FR-GUI-002, FR-GUI-003
Generated: 2025-11-12T23:00:00Z
"""

import pytest
import time
from PySide6.QtCore import Qt


@pytest.mark.e2e
@pytest.mark.gui
class TestApplicationLaunchWorkflow:
    """Test suite for application launch and initialization workflow."""

    def test_complete_application_launch_workflow(self, qtbot, mock_message_box):
        """
        Test complete application launch workflow.

        Scenario: User launches application and verifies it's ready to use

        Given: Application is not running
        When: MainWindow is created and shown
        Then:
            - Window appears within acceptable time
            - Window has correct title and size
            - Menu bar is visible with all menus
            - Central widget is present
            - Application is responsive

        Related: FR-GUI-001 (AC-GUI-001-01)
        """
        from app.presentation.main_window import MainWindow

        start_time = time.time()

        # Launch application
        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window, timeout=2000)

        launch_time = (time.time() - start_time) * 1000

        # Verify launch time < 1 second
        assert launch_time < 1000, f"Launch took {launch_time}ms, expected < 1000ms"

        # Verify window properties
        assert window.isVisible()
        assert window.windowTitle() == "SimplePySideApp"
        assert window.width() == 800
        assert window.height() == 600

        # Verify menu bar
        menu_bar = window.menuBar()
        assert menu_bar is not None
        assert menu_bar.isVisible()

        menus = [action.text().replace('&', '') for action in menu_bar.actions()]
        assert "File" in menus
        assert "Edit" in menus
        assert "Help" in menus

        # Verify central widget
        central_widget = window.centralWidget()
        assert central_widget is not None
        assert central_widget.isVisible()

        # Verify window is responsive (can accept input)
        assert window.isActiveWindow() or True  # May not be active in test environment


@pytest.mark.e2e
@pytest.mark.gui
class TestFileMenuWorkflow:
    """Test suite for File menu complete workflows."""

    def test_file_menu_exploration_workflow(self, qtbot, mock_message_box):
        """
        Test user exploring File menu options.

        Scenario: User opens File menu and explores all options

        Given: Application is running
        When: User clicks File menu and tries each action
        Then: All actions work as expected

        Related: FR-GUI-002
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Step 1: Open File menu
        file_menu = window.menuBar().actions()[0].menu()
        assert file_menu is not None
        assert "File" in file_menu.title()

        # Step 2: Try New action
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

        # Step 3: Try Open action
        qtbot.keyClick(window, Qt.Key_O, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 2
        assert mock_message_box['information'][1]['text'] == "Open clicked"

        # Step 4: Try Save action
        qtbot.keyClick(window, Qt.Key_S, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 3
        assert mock_message_box['information'][2]['text'] == "Save clicked"

        # All actions worked correctly

    def test_new_document_workflow(self, qtbot, mock_message_box):
        """
        Test creating new document workflow.

        Scenario: User wants to create a new document

        Given: Application is running
        When: User clicks File → New or presses Ctrl+N
        Then: New clicked message appears (placeholder for future file creation)

        Related: FR-GUI-002 (AC-GUI-002-01, AC-GUI-002-02)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # User presses Ctrl+N
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        # Verify action triggered
        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

    def test_application_exit_workflow(self, qtbot, mock_qapplication_quit):
        """
        Test application exit workflow.

        Scenario: User wants to close the application

        Given: Application is running with work completed
        When: User presses Ctrl+Q or clicks File → Exit
        Then: Application closes cleanly without errors

        Related: FR-GUI-002 (AC-GUI-002-05), FR-GUI-001 (BR-GUI-001)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # User presses Ctrl+Q to exit
        qtbot.keyClick(window, Qt.Key_Q, Qt.ControlModifier)
        qtbot.wait(100)

        # Verify quit was called
        assert len(mock_qapplication_quit) == 1


@pytest.mark.e2e
@pytest.mark.gui
class TestEditMenuWorkflow:
    """Test suite for Edit menu complete workflows."""

    def test_undo_redo_workflow(self, qtbot, mock_message_box):
        """
        Test undo/redo workflow.

        Scenario: User performs actions and uses undo/redo

        Given: Application is running
        When: User performs Undo (Ctrl+Z) then Redo (Ctrl+Y)
        Then: Actions are triggered correctly

        Related: FR-GUI-002 (AC-GUI-002-07, AC-GUI-002-08)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Step 1: User presses Ctrl+Z (Undo)
        qtbot.keyClick(window, Qt.Key_Z, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Undo clicked"

        # Step 2: User presses Ctrl+Y (Redo)
        qtbot.keyClick(window, Qt.Key_Y, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 2
        assert mock_message_box['information'][1]['text'] == "Redo clicked"


@pytest.mark.e2e
@pytest.mark.gui
class TestHelpMenuWorkflow:
    """Test suite for Help menu complete workflows."""

    def test_view_about_information_workflow(self, qtbot, mock_message_box):
        """
        Test viewing application information workflow.

        Scenario: User wants to see application version and information

        Given: Application is running
        When: User clicks Help → About
        Then: About dialog shows application name, version, description

        Related: FR-GUI-002 (AC-GUI-002-09)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Find Help menu
        help_menu = window.menuBar().actions()[2].menu()

        # Find and trigger About action
        about_action = None
        for action in help_menu.actions():
            if "About" in action.text():
                about_action = action
                break

        assert about_action is not None
        about_action.trigger()
        qtbot.wait(50)

        # Verify About dialog shown
        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['title'] == "About SimplePySideApp"

        message = mock_message_box['information'][0]['text']
        assert "SimplePySideApp" in message
        assert "v1.0" in message or "1.0" in message


@pytest.mark.e2e
@pytest.mark.gui
class TestKeyboardShortcutWorkflow:
    """Test suite for keyboard-driven workflows."""

    def test_keyboard_only_navigation_workflow(self, qtbot, mock_message_box):
        """
        Test complete workflow using only keyboard (no mouse).

        Scenario: Power user navigates application using only keyboard

        Given: Application is running with focus
        When: User navigates using keyboard shortcuts
        Then: All actions are accessible via keyboard

        Related: FR-GUI-003 (AC-GUI-003-09, BR-GUI-013)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Keyboard-only workflow
        actions_sequence = [
            (Qt.Key_N, Qt.ControlModifier, "New clicked"),
            (Qt.Key_O, Qt.ControlModifier, "Open clicked"),
            (Qt.Key_S, Qt.ControlModifier, "Save clicked"),
            (Qt.Key_Z, Qt.ControlModifier, "Undo clicked"),
            (Qt.Key_Y, Qt.ControlModifier, "Redo clicked"),
        ]

        for i, (key, modifier, expected_text) in enumerate(actions_sequence):
            qtbot.keyClick(window, key, modifier)
            qtbot.wait(50)

            assert len(mock_message_box['information']) == i + 1
            assert mock_message_box['information'][i]['text'] == expected_text

    def test_shortcut_discovery_workflow(self, qtbot):
        """
        Test user discovering keyboard shortcuts through menus.

        Scenario: New user opens menus to discover keyboard shortcuts

        Given: Application is running
        When: User opens each menu
        Then: Shortcuts are displayed next to menu items

        Related: FR-GUI-002 (AC-GUI-002-10, BR-GUI-003)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Check File menu shortcuts
        file_menu = window.menuBar().actions()[0].menu()
        file_actions = [a for a in file_menu.actions() if not a.isSeparator()]

        # Verify shortcuts are set (displayed to user)
        new_action = file_actions[0]
        assert not new_action.shortcut().isEmpty()

        open_action = file_actions[1]
        assert not open_action.shortcut().isEmpty()

        save_action = file_actions[2]
        assert not save_action.shortcut().isEmpty()

        # Check Edit menu shortcuts
        edit_menu = window.menuBar().actions()[1].menu()
        edit_actions = edit_menu.actions()

        undo_action = edit_actions[0]
        assert not undo_action.shortcut().isEmpty()

        redo_action = edit_actions[1]
        assert not redo_action.shortcut().isEmpty()


@pytest.mark.e2e
@pytest.mark.gui
@pytest.mark.slow
class TestWindowManagementWorkflow:
    """Test suite for window management complete workflows."""

    def test_window_resize_and_interaction_workflow(self, qtbot, mock_message_box):
        """
        Test resizing window and continuing to use application.

        Scenario: User resizes window to fit their screen and continues working

        Given: Application is running at default size (800x600)
        When: User resizes to 1024x768 and uses menus
        Then: Application remains responsive and menus work

        Related: FR-GUI-001 (AC-GUI-001-02), FR-GUI-003 (AC-GUI-003-16)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # User resizes window
        window.resize(1024, 768)
        qtbot.wait(200)

        assert window.width() == 1024
        assert window.height() == 768

        # User continues working - tries New action
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

        # Menu bar should stretch to new width
        menu_bar = window.menuBar()
        assert menu_bar.width() == 1024

    def test_minimize_restore_continue_workflow(self, qtbot, mock_message_box):
        """
        Test minimizing window, restoring, and continuing work.

        Scenario: User minimizes application, then restores and continues

        Given: Application is running with menus working
        When: User minimizes then restores window
        Then: Application state is preserved and menus still work

        Related: FR-GUI-001 (AC-GUI-001-04), FR-GUI-003 (AC-GUI-003-08)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # User minimizes window
        window.showMinimized()
        qtbot.wait(200)

        assert window.isMinimized()

        # User restores window
        window.showNormal()
        qtbot.wait(200)

        assert not window.isMinimized()
        assert window.isVisible()

        # User continues working
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

    def test_maximize_restore_workflow(self, qtbot, mock_message_box):
        """
        Test maximizing and restoring window workflow.

        Scenario: User maximizes window for more space, then restores

        Given: Application is running at default size
        When: User maximizes window, works, then restores to normal
        Then: Window returns to original size and menus still work

        Related: FR-GUI-001 (AC-GUI-001-05, AC-GUI-001-06)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        initial_size = (window.width(), window.height())

        # User maximizes
        window.showMaximized()
        qtbot.wait(200)

        assert window.isMaximized()

        # User works while maximized
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1

        # User restores window
        window.showNormal()
        qtbot.wait(200)

        assert not window.isMaximized()
        assert window.width() == initial_size[0]
        assert window.height() == initial_size[1]


@pytest.mark.e2e
@pytest.mark.gui
@pytest.mark.slow
class TestCompleteUserSession:
    """Test suite for complete user session scenarios."""

    def test_typical_user_session_workflow(self, qtbot, mock_message_box, mock_qapplication_quit):
        """
        Test typical user session from launch to exit.

        Scenario: Complete user session with multiple actions

        Given: User launches application
        When: User performs various actions and exits
        Then: All actions work correctly throughout session

        Related: All FR-GUI requirements
        """
        from app.presentation.main_window import MainWindow

        # Step 1: Launch application
        start_time = time.time()
        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)
        launch_time = (time.time() - start_time) * 1000

        assert launch_time < 1000
        assert window.isVisible()

        # Step 2: User creates new document
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        # Step 3: User opens file
        qtbot.keyClick(window, Qt.Key_O, Qt.ControlModifier)
        qtbot.wait(50)

        # Step 4: User makes changes and saves
        qtbot.keyClick(window, Qt.Key_S, Qt.ControlModifier)
        qtbot.wait(50)

        # Step 5: User makes mistake and undoes
        qtbot.keyClick(window, Qt.Key_Z, Qt.ControlModifier)
        qtbot.wait(50)

        # Step 6: User redoes
        qtbot.keyClick(window, Qt.Key_Y, Qt.ControlModifier)
        qtbot.wait(50)

        # Step 7: User checks About information
        help_menu = window.menuBar().actions()[2].menu()
        about_action = help_menu.actions()[0]
        about_action.trigger()
        qtbot.wait(50)

        # Step 8: User exits application
        qtbot.keyClick(window, Qt.Key_Q, Qt.ControlModifier)
        qtbot.wait(100)

        # Verify all actions executed correctly
        assert len(mock_message_box['information']) == 6
        assert mock_qapplication_quit[0] is True

    def test_stressed_user_workflow(self, qtbot, mock_message_box):
        """
        Test stressed user rapidly clicking multiple actions.

        Scenario: User rapidly tries different features

        Given: Application is running
        When: User rapidly clicks different menu items
        Then: Application handles all actions without crashing

        Related: FR-GUI-002 (AC-GUI-002-12, BR-GUI-004)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Rapid random actions
        rapid_actions = [
            Qt.Key_N,  # New
            Qt.Key_O,  # Open
            Qt.Key_S,  # Save
            Qt.Key_Z,  # Undo
            Qt.Key_Y,  # Redo
            Qt.Key_N,  # New again
            Qt.Key_S,  # Save again
        ]

        for key in rapid_actions:
            qtbot.keyClick(window, key, Qt.ControlModifier)
            qtbot.wait(20)  # Very short wait (rapid clicking)

        # Application should survive and all actions should execute
        assert len(mock_message_box['information']) == 7
        assert window.isVisible()
