"""
Pytest configuration and shared fixtures for SimplePySideApp tests.

Generated by: testing-agent
Source: tests/conftest.py
Requirements: FR-GUI-001, FR-GUI-002, FR-GUI-003
Generated: 2025-11-12T23:00:00Z
"""

import sys
import pytest
from unittest.mock import Mock, MagicMock
from PySide6.QtWidgets import QApplication, QWidget, QMessageBox
from PySide6.QtCore import Qt


@pytest.fixture(scope="session")
def qapp():
    """
    Create QApplication instance for the test session.

    This fixture creates a single QApplication instance that is shared
    across all tests in the session.
    """
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    yield app
    # Do not quit the application during session
    # Qt handles cleanup automatically


@pytest.fixture
def qtbot(qapp, qtbot):
    """
    Enhanced qtbot fixture with QApplication reference.

    Provides pytest-qt's qtbot with access to QApplication instance.
    """
    return qtbot


@pytest.fixture
def mock_message_box(monkeypatch):
    """
    Mock QMessageBox to capture messages instead of displaying them.

    Returns:
        dict: Dictionary containing lists of captured messages
            - 'information': List of information message calls
            - 'critical': List of critical message calls
            - 'warning': List of warning message calls

    Example:
        def test_action(mock_message_box):
            handler.on_new()
            assert len(mock_message_box['information']) == 1
            assert mock_message_box['information'][0]['text'] == "New clicked"
    """
    messages = {
        'information': [],
        'critical': [],
        'warning': []
    }

    def mock_information(parent, title, text):
        messages['information'].append({
            'parent': parent,
            'title': title,
            'text': text
        })
        return QMessageBox.Ok

    def mock_critical(parent, title, text):
        messages['critical'].append({
            'parent': parent,
            'title': title,
            'text': text
        })
        return QMessageBox.Ok

    def mock_warning(parent, title, text):
        messages['warning'].append({
            'parent': parent,
            'title': title,
            'text': text
        })
        return QMessageBox.Ok

    monkeypatch.setattr(QMessageBox, "information", mock_information)
    monkeypatch.setattr(QMessageBox, "critical", mock_critical)
    monkeypatch.setattr(QMessageBox, "warning", mock_warning)

    return messages


@pytest.fixture
def mock_parent_widget():
    """
    Create a mock parent widget for testing handlers.

    Returns:
        Mock: Mock QWidget instance that can be used as parent
    """
    parent = Mock(spec=QWidget)
    parent.isVisible = Mock(return_value=True)
    parent.isActiveWindow = Mock(return_value=True)
    return parent


@pytest.fixture
def sample_window_geometry():
    """
    Provide sample window geometry for tests.

    Returns:
        dict: Dictionary with window dimensions
    """
    return {
        'width': 800,
        'height': 600,
        'min_width': 400,
        'min_height': 300,
        'x': 100,
        'y': 100
    }


@pytest.fixture
def sample_screen_geometry():
    """
    Provide sample screen geometry for tests.

    Returns:
        dict: Dictionary with screen dimensions
    """
    return {
        'width': 1920,
        'height': 1080,
        'x': 0,
        'y': 0
    }


@pytest.fixture
def mock_qapplication_quit(monkeypatch):
    """
    Mock QApplication.quit() to prevent test runner from exiting.

    Returns:
        Mock: Mock function that tracks quit() calls
    """
    quit_calls = []

    def mock_quit():
        quit_calls.append(True)

    monkeypatch.setattr(QApplication, "quit", mock_quit)

    return quit_calls


@pytest.fixture(autouse=True)
def reset_qapplication_state():
    """
    Reset QApplication state between tests.

    This fixture runs automatically for every test to ensure
    clean state between test cases.
    """
    yield
    # Cleanup after test
    app = QApplication.instance()
    if app:
        # Process pending events
        app.processEvents()


# Test data fixtures

@pytest.fixture
def file_menu_actions():
    """
    Expected File menu actions with shortcuts.

    Returns:
        list: List of dictionaries with action details
    """
    return [
        {'text': 'New', 'shortcut': 'Ctrl+N'},
        {'text': 'Open', 'shortcut': 'Ctrl+O'},
        {'text': 'Save', 'shortcut': 'Ctrl+S'},
        {'text': 'Exit', 'shortcut': 'Ctrl+Q'}
    ]


@pytest.fixture
def edit_menu_actions():
    """
    Expected Edit menu actions with shortcuts.

    Returns:
        list: List of dictionaries with action details
    """
    return [
        {'text': 'Undo', 'shortcut': 'Ctrl+Z'},
        {'text': 'Redo', 'shortcut': 'Ctrl+Y'}
    ]


@pytest.fixture
def help_menu_actions():
    """
    Expected Help menu actions.

    Returns:
        list: List of dictionaries with action details
    """
    return [
        {'text': 'About', 'shortcut': None}
    ]


@pytest.fixture
def expected_menu_structure():
    """
    Expected complete menu structure.

    Returns:
        dict: Dictionary mapping menu names to actions
    """
    return {
        'File': ['New', 'Open', 'Save', '---', 'Exit'],
        'Edit': ['Undo', 'Redo'],
        'Help': ['About']
    }


# Parametrize helpers

def pytest_configure(config):
    """
    Register custom markers for pytest.
    """
    config.addinivalue_line(
        "markers", "unit: mark test as a unit test"
    )
    config.addinivalue_line(
        "markers", "integration: mark test as an integration test"
    )
    config.addinivalue_line(
        "markers", "e2e: mark test as an end-to-end test"
    )
    config.addinivalue_line(
        "markers", "slow: mark test as slow-running"
    )
    config.addinivalue_line(
        "markers", "gui: mark test as requiring GUI/display"
    )
