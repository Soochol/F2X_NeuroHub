"""
Integration tests for menu system and action handlers.

Generated by: testing-agent
Source: app/presentation/main_window.py, app/presentation/menu_bar.py, app/handlers/*
Requirements: FR-GUI-002, FR-GUI-003
Generated: 2025-11-12T23:00:00Z
"""

import pytest
from PySide6.QtCore import Qt
from PySide6.QtWidgets import QApplication


@pytest.mark.integration
class TestMenuActionIntegration:
    """Test suite for menu → action → handler integration."""

    def test_main_window_file_menu_new_action_connected(self, qtbot, mock_message_box):
        """
        Test File → New action is connected and triggers handler.

        Given: MainWindow is created with menu bar and handlers
        When: File → New action is triggered
        Then: FileActionHandler.on_new() is called and shows message

        Related: FR-GUI-002 (AC-GUI-002-01)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        # Find File menu
        file_menu = window.menuBar().actions()[0].menu()

        # Find New action
        new_action = None
        for action in file_menu.actions():
            if "New" in action.text():
                new_action = action
                break

        assert new_action is not None

        # Trigger action
        new_action.trigger()
        qtbot.wait(50)

        # Verify handler was called
        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

    def test_file_menu_open_action_integration(self, qtbot, mock_message_box):
        """
        Test File → Open action integration.

        Given: MainWindow with connected actions
        When: File → Open is triggered
        Then: "Open clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-03)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        file_menu = window.menuBar().actions()[0].menu()

        open_action = None
        for action in file_menu.actions():
            if "Open" in action.text():
                open_action = action
                break

        assert open_action is not None
        open_action.trigger()
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Open clicked"

    def test_file_menu_save_action_integration(self, qtbot, mock_message_box):
        """
        Test File → Save action integration.

        Given: MainWindow with connected actions
        When: File → Save is triggered
        Then: "Save clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-04)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        file_menu = window.menuBar().actions()[0].menu()

        save_action = None
        for action in file_menu.actions():
            if "Save" in action.text():
                save_action = action
                break

        assert save_action is not None
        save_action.trigger()
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Save clicked"

    def test_file_menu_exit_action_integration(self, qtbot, mock_qapplication_quit):
        """
        Test File → Exit action integration.

        Given: MainWindow with connected actions
        When: File → Exit is triggered
        Then: QApplication.quit() is called

        Related: FR-GUI-002 (AC-GUI-002-05)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        file_menu = window.menuBar().actions()[0].menu()

        exit_action = None
        for action in file_menu.actions():
            if "Exit" in action.text():
                exit_action = action
                break

        assert exit_action is not None
        exit_action.trigger()
        qtbot.wait(50)

        assert len(mock_qapplication_quit) == 1

    def test_edit_menu_undo_action_integration(self, qtbot, mock_message_box):
        """
        Test Edit → Undo action integration.

        Given: MainWindow with connected actions
        When: Edit → Undo is triggered
        Then: "Undo clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-07)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        edit_menu = window.menuBar().actions()[1].menu()

        undo_action = None
        for action in edit_menu.actions():
            if "Undo" in action.text():
                undo_action = action
                break

        assert undo_action is not None
        undo_action.trigger()
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Undo clicked"

    def test_edit_menu_redo_action_integration(self, qtbot, mock_message_box):
        """
        Test Edit → Redo action integration.

        Given: MainWindow with connected actions
        When: Edit → Redo is triggered
        Then: "Redo clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-08)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        edit_menu = window.menuBar().actions()[1].menu()

        redo_action = None
        for action in edit_menu.actions():
            if "Redo" in action.text():
                redo_action = action
                break

        assert redo_action is not None
        redo_action.trigger()
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Redo clicked"

    def test_help_menu_about_action_integration(self, qtbot, mock_message_box):
        """
        Test Help → About action integration.

        Given: MainWindow with connected actions
        When: Help → About is triggered
        Then: About dialog appears with correct information

        Related: FR-GUI-002 (AC-GUI-002-09)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        help_menu = window.menuBar().actions()[2].menu()

        about_action = None
        for action in help_menu.actions():
            if "About" in action.text():
                about_action = action
                break

        assert about_action is not None
        about_action.trigger()
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['title'] == "About SimplePySideApp"


@pytest.mark.integration
class TestKeyboardShortcutIntegration:
    """Test suite for keyboard shortcut integration."""

    def test_ctrl_n_triggers_new_action(self, qtbot, mock_message_box):
        """
        Test Ctrl+N shortcut triggers New action without opening menu.

        Given: MainWindow has focus
        When: Ctrl+N is pressed
        Then: "New clicked" message appears (File menu does not open)

        Related: FR-GUI-002 (AC-GUI-002-02, AC-GUI-002-15)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Press Ctrl+N
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(100)

        # Verify action triggered
        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

    def test_ctrl_o_triggers_open_action(self, qtbot, mock_message_box):
        """
        Test Ctrl+O shortcut triggers Open action.

        Given: MainWindow has focus
        When: Ctrl+O is pressed
        Then: "Open clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-03)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        qtbot.keyClick(window, Qt.Key_O, Qt.ControlModifier)
        qtbot.wait(100)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Open clicked"

    def test_ctrl_s_triggers_save_action(self, qtbot, mock_message_box):
        """
        Test Ctrl+S shortcut triggers Save action.

        Given: MainWindow has focus
        When: Ctrl+S is pressed
        Then: "Save clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-04)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        qtbot.keyClick(window, Qt.Key_S, Qt.ControlModifier)
        qtbot.wait(100)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Save clicked"

    def test_ctrl_q_triggers_exit_action(self, qtbot, mock_qapplication_quit):
        """
        Test Ctrl+Q shortcut triggers Exit action.

        Given: MainWindow has focus
        When: Ctrl+Q is pressed
        Then: QApplication.quit() is called

        Related: FR-GUI-002 (AC-GUI-002-05)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        qtbot.keyClick(window, Qt.Key_Q, Qt.ControlModifier)
        qtbot.wait(100)

        assert len(mock_qapplication_quit) == 1

    def test_ctrl_z_triggers_undo_action(self, qtbot, mock_message_box):
        """
        Test Ctrl+Z shortcut triggers Undo action.

        Given: MainWindow has focus
        When: Ctrl+Z is pressed
        Then: "Undo clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-07)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        qtbot.keyClick(window, Qt.Key_Z, Qt.ControlModifier)
        qtbot.wait(100)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Undo clicked"

    def test_ctrl_y_triggers_redo_action(self, qtbot, mock_message_box):
        """
        Test Ctrl+Y shortcut triggers Redo action.

        Given: MainWindow has focus
        When: Ctrl+Y is pressed
        Then: "Redo clicked" message appears

        Related: FR-GUI-002 (AC-GUI-002-08)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        qtbot.keyClick(window, Qt.Key_Y, Qt.ControlModifier)
        qtbot.wait(100)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Redo clicked"

    def test_shortcuts_work_when_menu_closed(self, qtbot, mock_message_box):
        """
        Test keyboard shortcuts work without opening menus.

        Given: MainWindow is displayed with all menus closed
        When: Ctrl+S is pressed
        Then: Action triggers without opening File menu

        Related: FR-GUI-002 (AC-GUI-002-15)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()
        qtbot.waitExposed(window)

        # Ensure no menu is open
        menu_bar = window.menuBar()
        assert menu_bar.activeAction() is None

        # Trigger shortcut
        qtbot.keyClick(window, Qt.Key_S, Qt.ControlModifier)
        qtbot.wait(100)

        # Verify action triggered
        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "Save clicked"


@pytest.mark.integration
class TestMenuSequences:
    """Test suite for action sequences and state management."""

    def test_sequential_menu_actions_independent(self, qtbot, mock_message_box):
        """
        Test sequential menu actions are independent (no state pollution).

        Given: MainWindow with all menus
        When: Sequence of actions is triggered: New → Open → Save → Undo
        Then: Each action shows correct message in order

        Related: FR-GUI-002 (AC-GUI-002-17)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        # Trigger actions via shortcuts
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        qtbot.keyClick(window, Qt.Key_O, Qt.ControlModifier)
        qtbot.wait(50)

        qtbot.keyClick(window, Qt.Key_S, Qt.ControlModifier)
        qtbot.wait(50)

        qtbot.keyClick(window, Qt.Key_Z, Qt.ControlModifier)
        qtbot.wait(50)

        # Verify all messages in correct order
        assert len(mock_message_box['information']) == 4
        assert mock_message_box['information'][0]['text'] == "New clicked"
        assert mock_message_box['information'][1]['text'] == "Open clicked"
        assert mock_message_box['information'][2]['text'] == "Save clicked"
        assert mock_message_box['information'][3]['text'] == "Undo clicked"

    def test_rapid_action_triggers(self, qtbot, mock_message_box):
        """
        Test rapid action triggers are handled correctly.

        Given: MainWindow is displayed
        When: New action is triggered 5 times rapidly
        Then: 5 message boxes appear sequentially (modal blocking)

        Related: FR-GUI-002 (AC-GUI-002-12)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        # Rapid key presses
        for _ in range(5):
            qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
            qtbot.wait(20)

        assert len(mock_message_box['information']) == 5
        for msg in mock_message_box['information']:
            assert msg['text'] == "New clicked"


@pytest.mark.integration
class TestWindowMenuIntegration:
    """Test suite for window state and menu integration."""

    def test_menu_accessible_after_window_resize(self, qtbot, mock_message_box):
        """
        Test menu remains accessible after window resize.

        Given: MainWindow is displayed at default size
        When: Window is resized to 1024x768, then New action triggered
        Then: Action still works correctly

        Related: FR-GUI-001 (AC-GUI-001-02), FR-GUI-002
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        # Resize window
        window.resize(1024, 768)
        qtbot.wait(100)

        # Trigger action
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"

    def test_menu_accessible_after_minimize_restore(self, qtbot, mock_message_box):
        """
        Test menu remains accessible after minimize and restore.

        Given: MainWindow is minimized then restored
        When: New action is triggered
        Then: Action works correctly

        Related: FR-GUI-001 (AC-GUI-001-04), FR-GUI-002
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)
        window.show()

        # Minimize
        window.showMinimized()
        qtbot.wait(200)

        # Restore
        window.showNormal()
        qtbot.wait(200)

        # Trigger action
        qtbot.keyClick(window, Qt.Key_N, Qt.ControlModifier)
        qtbot.wait(50)

        assert len(mock_message_box['information']) == 1
        assert mock_message_box['information'][0]['text'] == "New clicked"


@pytest.mark.integration
class TestMenuSeparators:
    """Test suite for menu separator integration."""

    def test_file_menu_has_separator_before_exit(self, qtbot):
        """
        Test File menu has visible separator before Exit action.

        Given: MainWindow is created
        When: File menu structure is inspected
        Then: Separator exists before Exit action

        Related: FR-GUI-002 (AC-GUI-002-06, BR-GUI-007)
        """
        from app.presentation.main_window import MainWindow

        window = MainWindow()
        qtbot.addWidget(window)

        file_menu = window.menuBar().actions()[0].menu()
        actions = file_menu.actions()

        # Find separator
        separator_found = False
        for i, action in enumerate(actions):
            if action.isSeparator():
                separator_found = True
                # Verify next action is Exit
                if i + 1 < len(actions):
                    next_action = actions[i + 1]
                    assert "Exit" in next_action.text()

        assert separator_found
